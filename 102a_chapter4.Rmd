---
title: "Chapter 4 Notes"
author: "Joshua Susanto"
date: '2023-02-07'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



## CHAPTER 4

QUESTIONS:
regex sets
any
- have to use with filter and groupby
trim 
- can specify left right or both to trim whitespace in a character
join unique keys
- when two keys are equal the next column is looked at to determine the unique key
- primary keys must be unique, so if there are not unique values in our column then that column is not a primary key

```{r}
library(tidyverse)
library(htmlwidgets)
fives <- c("5.00", "5100", "5-00", "5 00")
str_view(fives,"5.00") 
```

metacharacters only for the second argument and not for the characters we want to view

```{r}
triplets <- c("193", "123", "ABC", ":-)")
str_view(triplets, "[0-9][0-9][0-9]")
```

The pattern [ˆˆ] can be used to mean anything except the caret. But wait: I thought metacharacters needed to be escaped to be interpreted as literal characters?


Most metacharacters inside a character set are already escaped.
This implies that you do not need to escape them using double
backslashes.
Not all metacharacters become literal characters when they appear
inside a character set. The exceptions are the opening bracket [,
the closing bracket ], the dash -, the caret ˆ (if at the front or by
itself), and the backslash \.
The dot . inside the character set now represents the literal dot
character rather than the wildcard character.

it is important that the caret ˆ is the first character inside\
the character set, otherwise the set is not a negative one.\
For example, the pattern [A-Zˆ] mean any one upper case letter or\
the caret character.

```{r}
basic <- c("1", "a", "A", "&", "-", "^", ".")
str_view(basic, "[^^]")
str_view(basic, "[^\\^]")
str_view(basic, "[^A-Z]")
str_view(basic, "[^.]")
str_view(basic, "[^\\.]")
```


^ can be used as an anchor 
and as not for character sets 
anchors only work for the position theyre specified for

```{r}
text <- "the quick brown fox jumps over the lazy dog dog"
str_view_all(text, "\\Afox")
str_view_all(text, "ˆdog")
str_view_all(text, "\\Athe")
str_view_all(text, "^the")
```


```{r}
pnx <- c("pan", "pen", "pin", "p0n", "p.n",
"paun", "pwn3d")
str_view(pnx, "p[ae.iou]n")
str_view(pnx, "p\\wn")
```


```{r}
str_detect(pnx, "p[aeiou]") #is p followed by only [aeiou] (direct next character)
str_detect(pnx, "p\\w") #is p followed by any word character (direct next character only)
str_detect(pnx, "p[aeiou]n")
str_detect(pnx, "p\\wn") 
```


Anchors

```{r}
text <- "the quick brown fox jumps over the lazy dog dog"
str_replace_all(text, "the","-")
## [1] "- quick brown fox jumps over - lazy dog dog"
str_replace_all(text, "^the","-")
## [1] "- quick brown fox jumps over the lazy dog dog"
str_replace_all(text, "\\Athe","-") # same thing
## [1] "- quick brown fox jumps over the lazy dog dog"
```

when it is in a literal it acts as an anchor, while in a set it acts as NOT

```{r}
text <- "words jump jumping umpire pump umpteenth lumps"
str_replace_all(text, "\\bump","-") #is a front word boundary
## [1] "words jump jumping -ire pump -teenth lumps"
str_replace_all(text, "\\Bump","-") # is not a front word boundary
## [1] "words j- j-ing umpire p- umpteenth l-s"
str_replace_all(text, "ump\\b","-") # is an end word boundary
## [1] "words j- jumping umpire p- umpteenth lumps"
str_replace_all(text, "ump\\B","-") # is not an end word boundary     
## [1] "words jump j-ing -ire pump -teenth l-s"
```

Question: What is the difference between ˆ[0-9], [ˆ0-9], and
[0-9ˆ]?

ATTEMPT:
- first ^ means an anchor (first character is a digit between 0 and 9)
- second ^ means not a number between 0 and 9
- third ^ means ^ as a literal character 
ANSWER:
The caret ˆ outside of the character set is an anchor, so ˆ[0-9]
matches strings that begin with a digit.
The caret ˆ at the start of the character set is a negation, so
[ˆ0-9] matches a character that is not a digit.
The caret ˆ inside a character set but not at the start is the literal
caret character, so [0-9ˆ] matches a character that is a digit or
the caret.


QUANTIFIERS
Quantifiers can be attached to literal characters, character classes,
or groups to match repeats.
Pattern / Meaning
* / Match 0 or more (is greedy)
+ / Match 1 or more (is greedy)
? / Match 0 or 1
{3} / Match Exactly 3
{3,} / Match 3 or more
{3,5} / Match 3, 4 or 5

- match 0 refers to the quantifiers ability to match 0 length characters, or the character between every character
- when you match 1 or more then this is not an issue

```{r}
text <- "words or numbers 9,876 and combos123 like password_1234"
str_view_all(text, "\\S")
str_view_all(text, "\\S+")
```

- we can see that when we don't have a quantifier and ask to view all letters, they are highlighted one at a time
- conversely, when we use the + quantifiers, R searches for matches of length 1 or more, which in this case would be all of the words

```{r}
str_view_all(text, "\\d+")
```

- same concept but with digits in this example

```{r}
text2 <- "the year 1996 area code 310 combo123 password_1234 singledigit 5"
str_replace_all(text, "\\d?", "-")
str_replace_all(text2, "\\d?", "-")
```

- the ? quantifier matches either 0 or 1, so we are going to replace any 0 or 1 length digit characters with a '-'
- since a zero length character is technically all types of character, this would mean that we put a dash where every zero space is
- this creates even more zero spaces as we are adding a character and thus zeroes between them
- so we add dashes between all letters (including before the first letter) 
- even the space character has a zero char after it
- read it left to right
- whenever a length 1 replacement is found, this includes the zero character after it

```{r}
text3 <- "the year 1996 area code 310 combo123 password_1234 singledigit 5"
str_replace_all(text3, "\\d{3}", "-")
str_replace_all(text3, "\\d{2,4}", "-")
```

Quantifiers are by default greedy in the sense that they will return the
longest match.
Adding ? to a quantifier will make it ungreedy (or lazy).
``` {r}
text4 <- "Peter Piper picked a peck of pickled peppers"
str_extract(text4,"P.*r") # returns the whole thing up to peppers as that is the biggest match
str_extract(text4,"P.*?r") # returns Peter bc its the smallest match
```
- lazy returns the smallest available match that still satisfies the quantifier

```{r}
str_extract_all(text4, "P.*?r")
str_extract_all(text4,"[Pp].*?r")
```


GROUPING AND CAPTURING

- Parentheses ( ) define a group that groups together parts of a regular expression.
- Besides grouping part of a regular expression together, parentheses also create a numbered capturing group: Any matches to the part of the pattern defined by the parentheses can be referenced by group number, either for modification or replacement.
- By including ?: after the opening parenthesis, the group becomes a non-capturing group.
- For example, in the pattern (abc)(def)(?:ghi), the pattern (abc) creates capturing group 1, (def) creates capturing group 2, and (ghi) is a group that is not captured.
- Groups are used in conjunction with str_match() and str_match_all().
















