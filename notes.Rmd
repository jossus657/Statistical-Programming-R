---
title: "Untitled"
author: "Joshua Susanto"
date: '2023-02-07'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



## CHAPTER 4

QUESTIONS:
regex sets
any
- have to use with filter and groupby
trim 
join unique keys
- when two keys are equal the next column is looked at to determine the unique key

```{r}
library(tidyverse)
library(htmlwidgets)
fives <- c("5.00", "5100", "5-00", "5 00")
str_view(fives,"5.00") 
```

metacharacters only for the second argument and not for the characters we want to view

```{r}
triplets <- c("193", "123", "ABC", ":-)")
str_view(triplets, "[0-9][0-9][0-9]")
```

The pattern [ˆˆ] can be used to mean anything except the caret. But wait: I thought metacharacters needed to be escaped to be interpreted as literal characters?


Most metacharacters inside a character set are already escaped.
This implies that you do not need to escape them using double
backslashes.
Not all metacharacters become literal characters when they appear
inside a character set. The exceptions are the opening bracket [,
the closing bracket ], the dash -, the caret ˆ (if at the front or by
itself), and the backslash \.
The dot . inside the character set now represents the literal dot
character rather than the wildcard character.

it is important that the caret ˆ is the first character inside\
the character set, otherwise the set is not a negative one.\
For example, the pattern [A-Zˆ] mean any one upper case letter or\
the caret character.

```{r}
basic <- c("1", "a", "A", "&", "-", "^", ".")
str_view(basic, "[^^]")
str_view(basic, "[^\\^]")
str_view(basic, "[^A-Z]")
str_view(basic, "[^.]")
str_view(basic, "[^\\.]")
```


^ can be used as an anchor 
and as not for character sets 
anchors only work for the position theyre specified for

```{r}
text <- "the quick brown fox jumps over the lazy dog dog"
str_view_all(text, "\\Afox")
str_view_all(text, "ˆdog")
str_view_all(text, "\\Athe")
str_view_all(text, "^the")
```


```{r}
pnx <- c("pan", "pen", "pin", "p0n", "p.n",
"paun", "pwn3d")
str_view(pnx, "p[ae.iou]n")
str_view(pnx, "p\\wn")
```


```{r}
str_detect(pnx, "p[aeiou]") #is p followed by only [aeiou] (direct next character)
str_detect(pnx, "p\\w") #is p followed by any word character (direct next character only)
str_detect(pnx, "p[aeiou]n")
str_detect(pnx, "p\\wn") 
```


Anchors

```{r}
text <- "the quick brown fox jumps over the lazy dog dog"
str_replace_all(text, "the","-")
## [1] "- quick brown fox jumps over - lazy dog dog"
str_replace_all(text, "^the","-")
## [1] "- quick brown fox jumps over the lazy dog dog"
str_replace_all(text, "\\Athe","-") # same thing
## [1] "- quick brown fox jumps over the lazy dog dog"
```

when it is in a literal it acts as an anchor, while in a set it acts as NOT

```{r}
text <- "words jump jumping umpire pump umpteenth lumps"
str_replace_all(text, "\\bump","-") #is a front word boundary
## [1] "words jump jumping -ire pump -teenth lumps"
str_replace_all(text, "\\Bump","-") # is not a front word boundary
## [1] "words j- j-ing umpire p- umpteenth l-s"
str_replace_all(text, "ump\\b","-") # is an end word boundary
## [1] "words j- jumping umpire p- umpteenth lumps"
str_replace_all(text, "ump\\B","-") # is not an end word boundary     
## [1] "words jump j-ing -ire pump -teenth l-s"
```

Question: What is the difference between ˆ[0-9], [ˆ0-9], and
[0-9ˆ]?

ATTEMPT:
- first ^ means an anchor (first character is a digit between 0 and 9)
- second ^ means not a number between 0 and 9
- third ^ means ^ as a literal character 
ANSWER:
The caret ˆ outside of the character set is an anchor, so ˆ[0-9]
matches strings that begin with a digit.
The caret ˆ at the start of the character set is a negation, so
[ˆ0-9] matches a character that is not a digit.
The caret ˆ inside a character set but not at the start is the literal
caret character, so [0-9ˆ] matches a character that is a digit or
the caret.


QUANTIFIERS
Quantifiers can be attached to literal characters, character classes,
or groups to match repeats.
Pattern / Meaning
* / Match 0 or more (is greedy)
+ / Match 1 or more (is greedy)
? / Match 0 or 1
{3} / Match Exactly 3
{3,} / Match 3 or more
{3,5} / Match 3, 4 or 5