---
title: "102a Discussion 9"
author: "Joshua Susanto"
date: "2023-03-08"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

1: Dealing with Large Numbers
To simulate how the computer handles the computation with large floating point numbers we
define pqnumber objects to keep large numbers. This object should have four components. The
first one is either the integer +1 or the integer −1. It gives the sign of the number. The second
and third are p and q. And the fourth component is a vector of p + q + 1 integers between zero
and nine. For example, we can use the following object x to keep the number 87654.321.

```{r}
x <- structure(list(sign = 1, p = 3, q = 4, nums = 1:8), class = "pqnumber")
x
```


```{r}
carry_over <- function(z) {
  n <- length(z)
  carry <- 0
  for (i in 1:n) {
    zi <- z[i] + carry
    z[i] <- z[i]
  }
}
```


(a) Write a constructor function, an appropriate predicate function, appropriate coercion
functions, and a useful print() method. This question accounts for 25% of this assignment.

• The constructor takes the four arguments: sign, p, q, and nums. Then check if the
arguments satisfy all requirements for a pqnumber object. If not, stop with an
appropriate error message. If yes, return the object.
• A predicate is a function that returns a single TRUE or FALSE, like is.data.frame(), or
is.factor(). Your predicate function should be is pqnumber() and should behave as
expected.
• A useful print() method should allow users to print a pqnumber object with the
decimal representation defined as follows:
